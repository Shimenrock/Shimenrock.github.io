---
title: "InnoDB 加锁规则"
permalink: /dba/innodb-lock-rules/
excerpt: "InnoDB 加锁规则"
last_modified_at: 2020-02-06T21:36:11-04:00
categories: mysql
redirect_from:
  - /theme-setup/
toc: true
---
<!-- 
重学MySQL打卡行动Day18！

学习内容 : InnoDB的加锁规则 

对应篇目：
21 | 为什么我只查一行的语句，锁这么多？http://gk.link/a/101Oe
30 | 答疑文章（二）：用动态的观点看加锁 http://gk.link/a/1020p

在这两篇文章中，丁奇将MySQL的加锁规则总结为两个“原则”、两个“优化”和一个“bug”。

原则1：加锁的基本单位是next-key lock。
原则2：查找过程中访问到的对象才会加锁。
优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
-->

# 1.前提
1. MySQL 后面的版本可能会改变加锁策略，限于目前版本 5.x系列<= 5.7.24  8.0系列<= 8.0.13
2. 默认可重复读隔离级别。

# 2.规则
1. 原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。
2. 原则 2：查找过程中访问到的对象才会加锁。
3. 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
4. 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
5. 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

```
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```
<!-- 
重学MySQL打卡行动Day19！

学习内容：获得表行数的方法

对应篇目：
14 | count(*)这么慢，我该怎么办？http://gk.link/a/101B4

你知道count(*)语句到底是怎样实现的吗，MySQL又为什么会这样实现呢？如果应用中有这种频繁变更并需要统计表行数的需求，业务设计上又可以怎么做呢？

这些问题的答案，都在今天这篇文章中。

️学习完这部分之后请在小程序上记录学习笔记或者感悟，视为当日打卡成功，一周打卡≥3次即可获得阶段性奖励。

现在可以开始 Day19 打卡了，好的开始就是成功的一半，大家加油哦！-->

大家周末愉快呀~

第一阶段打卡已经结束啦，你们都完成了吗？

Day20~Day21 是周末，给大家放假哦！回顾一下本周学习篇目，没有学完的小伙伴要加油补卡啦~

Day15：
08 | 事务到底是隔离的还是不隔离的？http://gk.link/a/101rj

Day16：
19 | 为什么我只查一行的语句，也执行这么慢？http://gk.link/a/101KL

Day17：
20 | 幻读是什么，幻读有什么问题？http://gk.link/a/101Mp

Day18：
21 | 为什么我只查一行的语句，锁这么多？http://gk.link/a/101Oe
30 | 答疑文章（二）：用动态的观点看加锁 http://gk.link/a/1020p

Day19：
14 | count(*)这么慢，我该怎么办？http://gk.link/a/101B4

️学习完记得在小程序上记录学习笔记或者感悟，视为当日打卡成功，一周打卡≥3次即可获得阶段性奖励。
