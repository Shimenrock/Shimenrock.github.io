---
title: "webapp"
permalink: /pentesting/webapp/
excerpt: "webapp"
published: true
related: true
toc: true
toc_sticky: true
redirect_from:
  - /theme-setup/
categories: 
  - webapp
  - tomcat
---  


## 一、Java WebAPP组织结构

```
# tree manager
manager
├── images
│   ├── asf-logo.svg
│   └── tomcat.gif
├── index.jsp
├── META-INF
│   └── context.xml
├── status.xsd
├── WEB-INF
│   ├── jsp
│   │   ├── 401.jsp
│   │   ├── 403.jsp
│   │   ├── 404.jsp
│   │   ├── connectorCerts.jsp
│   │   ├── connectorCiphers.jsp
│   │   ├── connectorTrustedCerts.jsp
│   │   ├── sessionDetail.jsp
│   │   └── sessionsList.jsp
│   └── web.xml
└── xform.xsl

# tree host-manager/
host-manager/
├── images
│   ├── asf-logo.svg
│   └── tomcat.gif
├── index.jsp
├── manager.xml
├── META-INF
│   └── context.xml
└── WEB-INF
    ├── jsp
    │   ├── 401.jsp
    │   ├── 403.jsp
    │   └── 404.jsp
    └── web.xml
```

有特定的组织形式、层次型的目录结构；主要包含了servlet代码文件、JSP页面文件、类文件、部署描述符文件等；

/usr/local/tomcat/webapps/app1/

- /: webapp的根目录
- WEB-INF/：必须大写，非必须,无则找conf目录默认配置，当前webapp的私有资源目录，通常存放当前webapp自用的web.xml
- MEAT-INF/: 必须大写，非必须,无则找conf目录默认配置，当前webapp的私有资源目录，通常存放当前webapp自用的context.xml
- classes/: 此webapp的私有类
- lib/：此webapp的私有类，被打包为jar格式类
- index.jsp 主页

webapp归档格式
- .war: webapp
- .jar: EJB的类
- .rar: 资源适配器
- .ear: 企业级应用程序

IP:8080   /webapps/ROOT/

## 二、添加测试应用

1. 创建webapp特有的目录结构
   mkdir -pv myapp/{lib,classes,WEB-INF,META-INF}
2. 提供webapp各文件
   myapp/index.jsp

```
# cd webapps
# mkdir myapp/{lib,classes,WEB-INF,META-INF}  -pv

# cd  conf/   
# ls  默认读取公共web.xml context.xml
Catalina          catalina.properties  jaspic-providers.xml  logging.properties  tomcat-users.xml  web.xml
catalina.policy  context.xml          jaspic-providers.xsd  server.xml          tomcat-users.xsd

# vim myapp/index.jsp
<%@ page language="java" %>
<%@ page import="java.util.*" %>
<html>
    <head>
        <title>JSP Test Page</title>
    </head>
    <body>
        <% out.println("Hello, world."); %>
    </body>
</html>

# tree work/
work/
└── Catalina
    └── localhost
        ├── docs
        ├── examples
        ├── host-manager
        ├── manager
        ├── myapp
        │   └── org
        │       └── apache
        │           └── jsp
        │               ├── index_jsp.class
        │               └── index_jsp.java
        └── ROOT
            └── org
                └── apache
                    └── jsp
                        ├── index_jsp.class
                        └── index_jsp.java


# less work/Catalina/localhost/myapp/org/apache/jsp/index_jsp.java 
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/8.5.55
 * Generated at: 2020-06-08 13:12:07 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import java.util.*;
...
      out.write("\n");
      out.write("\n");
      out.write("<html>\n");
      out.write("\t    <head>\n");
      out.write("\t\t            <title>JSP Test Page</title>\n");
      out.write("\t\t\t        </head>\n");
      out.write("\t\t\t\t    <body>\n");
      out.write("\t\t\t\t\t            ");
 out.println("Hello, world."); 
      out.write("\n");
      out.write("\t\t\t\t\t\t        </body>\n");
      out.write("</html>\n");

```
## 三、部署

### 部署 deployment 操作：

deploy:部署，将webapp的源文件旋转于目标目录、配置tomcat服务器能够基于context.xml文件中定义的路径来访问此webapp;将其特有类通过class loader装载至tomcat

两种方式:
- 自动部署 auto deploy
- 手动部署 
  - 冷部署，把webapp复制到指定位置，而后启动tomcat
  - 热部署，在不停止tomcat的前提下进行部署，部署工具，如manager ant脚本  tcd(tomcat client deployer)等。
- undeploy 反部署，停止webapp，并从tomcat实例拆除其部分文件和部署名。
- stop 停止，不再向用户提供服务
- start 启动，处于停止状态的webapp
- redeploy 重写部署

### 自带部署应用程序
- manager
- host manager

### 四、manager管理程序

**Webapp管理工具**

**配置context.xml**

8.5以后默认配置只能本机登陆

```
# vim webapps/host-manager/META-INF/context.xml 
# vim webapps/manager/META-INF/context.xml 
```
原配置
  <Valve className="org.apache.catalina.valves.RemoteAddrValve"
         allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" />
方法1注释
<!--
<Valve className="org.apache.catalina.valves.RemoteAddrValve"
    allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" />
-->



方法2增加IP
    <Valve className="org.apache.catalina.valves.RemoteAddrValve"
         allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1|YOUR.IP.ADDRESS.HERE" />
方法3允许所有IP
    <Valve className="org.apache.catalina.valves.RemoteAddrValve"
         allow=".*" />
```

**配置用户**

```
# vim conf/tomcat-users.xml
<role rolename="manager-gui"/>
<user username="tomcat" password="tomcat" roles="manager-gui"/>
```
```
# catalina stop
注意，最小5s时间间隔
# catalina start
```

- manager-gui       (allows access to the HTML GUI and the status pages)HTML GUI & status pages
- manager-script    (allows access to the text interface and the status pages)文本接口  & status pages
- manager-jmx       (allows access to the JMX proxy and the status pages)JMX proxy & status pages 远程监控
- manager-status    (allows access to the status pages only)status pages 只读，只能查看不能管理

JVM状态
- Heap memory 堆内存
  - Eden Space 新生带-诞生区
  - Surivor Space 新生带-存活区
  - Tenured Gen 老年带
- Non-heap memory 非堆内存
  - Code Cache 代码缓存区
  - Compressed Class Space 压缩类空间
  - Metaspace  数据空间
  
GC 垃圾回收

苹果IOS是C语言，后来SWIFT开发，系统高效。
安卓是java程序，内存浪费严重，随着时间垃圾回收越来越多。

### 五、Host manager管理程序

Virtual Hosts管理工具

**配置用户**
```
# vim conf/tomcat-users.xml
<role rolename="admin-gui"/>
<user username="tomcat" password="tomcat" roles="manager-gui,admin-gui"/>
```

### 六、tomcat的主要配置文件结构

tomcat内存不能大于32G

```
<server>
    <service>
        <connector />
        <connector />
        <engine >
            <host name="">
            </host>
            <host name="">
            </host>
                <context />
                <context />
            </host>
        </engine>
    </service>
</server>
```

常见组件：
1. 服务区server:Tomcat 的一个实例，通常一个JVM只能包含一个Tomcat实例；因此，一台服务器上可以在启动多个JVM的情况下在每一共JVM中启动一共Tomcat实例，每个实例分属于一个独立的管理端口。顶级组件。
2. 服务service:一个服务组件通常包含一个引擎和与引擎相关联的一个或多个连接器。给服务命名可以方便管理员在日志文件中识别不同服务产生的日志。一个server可以包含多个service组件，但通常情况下只为一个service指派一个server。

连接器类组件：
3. 连接器connectors:负责连接客户端请求至Servlet容器内的web应用程序，通常指的是接收客户发来请求的位置及服务器端分配的端口。默认HTTP协议8080，一个引擎可以配置多个连接器，但连接器必须使用不同端口，默认连接器基于HTTP/1.1的Coyoto。同时Tomcat也支持AJP,JServ和JK2连接器

容器类组件：
4. 引擎Engine，指处理请求的Servlet引擎组件，即Catalina Servlet引擎。
5. 主机Host,虚拟主机，只支持基于FQDN的虚拟主机，一个引擎至少包含一个主机组件
6. 上下文Context,最内层次组件，表示web应用程序本身

被嵌套组件nested
这类组件通常包含于容器类组件中以提供具有管理功能的服务，它们不能包含其他组件，但有些却可以由不同层次的容器各自配置
7. 阀门Valve，用来拦截请求并在将其转至目标之前进行某种处理操作，类似于Servlet规范中定义的过滤器
8. 日志记录器logger，用于记录组件内部的状态信息，可被用于除Context之外的任何容器中。
9. 领域Realm，用于用户的认证和授权；在配置一个应用程序时，管理员可以为每个资源或资源组定义角色及权限，而这些访问控制功能的生效需要通过Realm来实现。


cp server.xml{,.backup}

AJP协议只有httpd和tomcat支持

#### 6.1 Server的相关属性
- className     用于实现此Server容器的完全限定类的名称，默认org.apache.catalina.core.StandarServer
- port          接受shutdown指令的端口，默认仅允许本机访问，默认8005
- shutdown      默认命令字符串SHUTDOWN
#### 6.2 Service
主要用于关联一个引擎和此引擎相关的连接器，每个连接器通过一个特定的端口和协议接入站请求，将其转发至关联引擎处理
```
<Service name="Catalina">
```
- className     用于实现service的类名，默认org.apache.catalina.core.StandarService
- name          服务名,默认Catalina
#### 6.3 Connector组件
工作模式
- Tomcat作为应用程序服务器：请求来自前端的web服务器，可能是Apache IIS Nginx
- Tomcat作为独立服务器，请求来自于web浏览器

Tomcat应考虑工作情形的请求，分别定义需要的连接器，才能正确接受来自于客户端的请求，一个引擎可以有一个或多个连接器。

属性
- HTTP连接器
- SSL连接器
- AJP 1.3连接器  （避免客户端跳过反向代理服务器之间访问tomcat服务器）
- proxy连接器

```
<Connector port="8080" protocol="HTTP/1.1"
    maxThreads=“150” connectionTimeout=“20000”
    redirectPort=“8443”>
```
- address           指定连接器监听地址，默认0.0.0.0
- maxThreads        支持的最大并发连接数，默认200
- port              监听端口，默认0
- protocol          默认HTTP/1.1 ，定义AJP通常为AJP/1.3
- redirectPort      如果某连接器支持HTTP，当接受客户端发来的HTTPS请求时，则转发此属性定义端口
- connectionTimeout 等待客户端发送请求的超时时间，单位毫秒，默认60000，即1分钟
- enableLoopup      是否通过request.getRemoteHost()进行DNS查询以获取客户端的主机名，默认true，非常耗时，配置flase
- acceptCount       设置等待队列的最大长度，通常在tomcat所有处理线程均处于繁忙状态时，新发来的请求将被放置于等待队列中。

```
<Connector port="8443"  
    maxThreads="150" minSpareThreads="25" maxSpareThreads="75"
    enableLookups="false" acceptCount="100" debug="0" scheme="https" secure="true"
    clientAuth="false" sslProtocol="TLS" />
    最小空闲线程，最大空闲线程                关闭debug
    不验证客户端（不要证书）   ssl的协议事TLS
    还需要指定加密证书和协议
```

#### 6.4 Engine
engine是Servlet处理器的一个实例，默认Catalina，engine需要defaulthost属性来为其定义一个接收所有发往非明确定义虚拟主机的请求的host组件
<Engine name="Catalina" defaultHost="localhost">

- defaultHost: Tomcat支持基于FQDN的虚拟主机，这些虚拟主机可以通过再Engine容器中定义不同的Host组件实现，在Engine中定义多个虚拟主机的主机名中，至少一个跟defaultHost定义的主机名称同名。
- name 组件名称，用于日志和错误信息记录时区别不同引擎
- jvmRoute

Engine容器中可以包含Realm   Host  Listener 和 Valve子容器

#### 6.5 Host
位于Engine容器中，用于接收请求并进行相应处理的主机或虚拟主机(IP或host name)

```
<Host name="localhost" appBase="webapps"
    unpackWARs="true" autoDeploy="true"
    xmlValidation="false" xmlNamespaceAware="false">
</Host>
```

- appBase           此Host的webapps目录，即存放非归档的web应用程序的目录或归档后的WAR文件目录路径；可使用基于$CALALINA_HOME的相对路径
- autoDeploy        在tomcat处于运行状态时，放置于appBase目录应用程序是否自动deploy，默认true，一般配置false
- unpackWars        在启动此webapps时是否对WAR格式的归档文件先进行展开，默认true 

```
<Engine name="Catalina" defaultHost="localhosts">
    <Host name="localhost" appBase="webapps">
        <Context path="" docBase="ROOT"/>
        <Contest path="/bbs" docBase="/web/bss" reloadable="true" crossContext="true"/>
    </Host>

    <Host name="mail.magedu.com" appBase="/web/mail">
        <Context path="/" docBase="ROOT" />
    </Host>
</Engine>
```

主机别名定义：
如果一个主机有两个或两个以上的主机名，额外的名称均可以以别名形式进行定义
<Host name="www.magedu.com" appBase="webapps" unpackWARs="true">
    <Alias>magedu.com</Alias>
</Host>


#### 6.6 Context
```
<!-- Tomcat Root Context -->
<Context path="" docBase="/web/webapps">

<!-- buzzin Context -->
<Context path="/bbs" 
    docBase="/web/threads/bbs"
    reloadable="true">
</Context>    

<!-- chat server -->
<Context path="/chat" docBase="/web/chat">

<!-- darian web -->
<Context path="/darian" docBase="darian"/>
```

在tomcat6中，每一个context定义也可以使用一个单独的XML文件，其文件目录为$CATALINA_HOME/conf/<engine name>/<host name>。可以用于Context中XML元素Loader  Manger Realm  Resources WatchedResource

- docBase           Web应用程序存放位置，可以使用相对路径，起始路径事appBase定义的路径；docBase路径名不能与相应appBase定义路径名有包含关系。比如deploy和deploy-bbs
- path              相对web服务器根路径而已的URI,如果为空，则表示根路径，如果context定义在单独xml文件，此属性不需要定义。
- reloadable        是否允许重新加载此context相关web应用程序的类，默认为false

#### 6.7 Realm
一个Realm表示一个安全上下文，它授权某个给定Context的用户列表和某用户所允许切换的角色相关定义的列表。定义Realm唯一必须提供的属性classname，是Realm的多个不同实现，用于表示Realm认证的用户及角色等认证信息存放位置
- JAASRealm     基于Java Authinitication and Authorization Service实现用户认证
- JDBCRealm     通过JDBC访问某关系型数据库实现用户认证
- JNDIRealm     基于JNDI使用目录服务实现认证信息存放
- MemoryRealm   查找tomcat-user.xml文件实现用户信息的获取
- UserDatabaseRealm  基于Userdatabase文件，通常是tomcat-user.xml
- 实现用户认证，它实现是一个完全可更新和持久有效的MemoryRealm，因此能够跟标准MemoryRealm兼容，它通过JNDI实现。

```
<Realm classNmae="org.apache.catalina.realm.UserDatabaseRealm" resourcName="UserDatabase"/>

<Realm className="org.apache.catalina.realm.JDBCRealm" debug="99"
    driverName="org.gjt.mm.mysql.Driver"
    connectionURL="jdbc:mysql://localhost/authority"
    connectionName="test" connectionPassword="test"
    userTable="users" userNameCol="user_name"
    userCredCol="user_pass"
    userRoleTable="user_roles" roleNameCol="role_name"/>
```

#### 6.8 Valve
Valve类似于过滤器，工作于Engine和HOST/Context之间、Host和Context之间、Context和web应用的某资源之间，可以多个valve，而valve的定义的次序决定了它生效的次序

- AccessLogValve            日志
- ExtendedAccessValve       扩展日志
- JDBCAccessLogValve        通过JDBC将访问日志信息发送到数据库
- ReuestDumperValve         请求转储Valve
- RemoteAddrValve           基于远程地址的访问控制
- RemoteHostValve           基于远程主机名称的访问控制
- SemaphoreValve            用于控制Tomcat主机上任何容器上的并发访问数量
- JvmRouteBinderValve       在配置多个Tomcat为以Apache通过mod_proxy或mod_jk作为前端的集群架构中，当期望停止某节点时，可以通过此Valve将用记请求定向至备用节点；使用此Valve必须使用JvmRouteSessionIDBinderListener
- ReplicationValve          专用与Tomcat集群架构中，可以在某个请求的session信息发生更改时触发session数据在各节点间进行复制
- SingleSignOn              将两个或多个需要对用户进行认证webapp在认证用户时连接在一起，即一次认证即可访问所有连接在一起的webapp
- ClusterSingleSingOn       对SingleSignOn的扩展，专用于Tomcat集群当中，需要结合ClusterSingleSignOnListerner进行工作。

```
<Context path="/probe" docBase="probe">
    <Valve className="org.apache.catalina.valve.RemoteAddrValve"
    allow="127\.0\.0\.1"/>
</Context>
allow 和 deny 以逗号分开IP地址列表，支持正则表达式，点号用于IP地址时需要转义。
```

#### 6.9 GlobalNamingResources
应用于整个服务器的JNDI映射，可以避免每个web应用程序都需要在各自的web.xml创建，这些web应用程序以WAR的形式存在时尤为有用。
- Environment
- Resource
- ResourceEnvRef

#### 6.10 WatchedResource
用于Context中监视指示的webapp程序文件的改变，并且能够在监视到文件内容发生改变时重新装载此文件

#### 6.11 Listener
用于创建和配置LifecycleListener对象，通常被开发人员用来创建和删除容器。

#### 6.12 Loader
Java的动态装载功能是其语言功能强大表现之一，Servlet容器使用此功能在运行时动态装载servlet和它们所依赖的类，Loader可以用于Context中控制java类的加载

注意 path给定的路径不能以"/"结尾
